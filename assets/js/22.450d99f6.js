(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{553:function(e,s,a){"use strict";a.r(s);var t=a(2),n=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"概念"}},[e._v("概念")]),e._v(" "),a("p",[e._v("在生产环境中使用 Docker，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享。\n容器中的数据管理方式有两种：")]),e._v(" "),a("ol",[a("li",[e._v("数据卷（Data Volumes）：容器内数据直接映射到本地主机环境")]),e._v(" "),a("li",[e._v("数据卷容器（Data Volumes Containers）：使用特定容器维护数据卷")])]),e._v(" "),a("h2",{attrs:{id:"数据卷"}},[e._v("数据卷")]),e._v(" "),a("p",[e._v("数据卷是一个可供容器使用的特殊目录，它将主机目录直接映射进容器，类似于 Linux 中的 mount 行为。\n数据卷提供了一些特性：")]),e._v(" "),a("ol",[a("li",[e._v("数据卷可以在容器之间共享和重用，容器间传递数据将变得高效与方便")]),e._v(" "),a("li",[e._v("对数据卷内数据的修改会立即生效，无论容器内操作还是主机操作")]),e._v(" "),a("li",[e._v("对数据卷的更新不会影响镜像，解耦开应用和数据")]),e._v(" "),a("li",[e._v("卷会一直存在，知道没有容器使用，可以安全地卸载它")])]),e._v(" "),a("h3",{attrs:{id:"_1-操作"}},[e._v("1. 操作")]),e._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 创建")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# docker volume create [OPTIONS] [VOLUME]")]),e._v("\ndocker volume create hello\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("根据 "),a("code",[e._v("docker inspect hello")]),e._v(" 可得知数据卷数据存放在 "),a("code",[e._v("/var/lib/docker/volumes/")]),e._v(" 下。")]),e._v(" "),a("h2",{attrs:{id:"数据卷容器"}},[e._v("数据卷容器")]),e._v(" "),a("p",[e._v("数据卷容器也是一个容器，但它的目的是专门提供数据卷给其他容器挂载。")]),e._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 创建数据卷容器")]),e._v("\ndocker run -it -v /dbdata --name dbdata ubuntu\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 接着可以在其他容器中挂载数据卷")]),e._v("\ndocker run -it --volumes-from dbdata --name db1 ubuntu\ndocker run -it --volumes-from dbdata --name db2 ubuntu\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 个人认为该形式并不好")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("注意 "),a("code",[e._v("dbdata")]),e._v(" 容器中使用了 "),a("code",[e._v("-v")]),e._v("，但其后仅跟随了 "),a("code",[e._v("/dbdata")]),e._v("，实际上会生成一个匿名的 volume，根据这个也可以推导出若跟随参数为 "),a("code",[e._v("hello/dbdata")]),e._v(" 则会创建一个 "),a("code",[e._v("hello")]),e._v(" volume，跳过先创建数据卷的步骤。")]),e._v(" "),a("p",[e._v("更进一步我们可以推导出 "),a("code",[e._v("-v")]),e._v(" 无法指定去掉 "),a("code",[e._v("./")]),e._v(" 的相对路径。")])])}),[],!1,null,null,null);s.default=n.exports}}]);